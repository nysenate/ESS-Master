/*! ess - v - 2016-11-03 */
function supplyNavigationController($scope, $location, appProps, locationService, categoryService, destinationService) {
    function onRequisitionOrderPage(path) {
        return path === appProps.ctxPath + "/supply/order";
    }
    function destinationIsSelected() {
        return destinationService.isDestinationConfirmed();
    }
    function updateSelectedCategoriesFromUrl() {
        var categoryNamesInUrl = locationService.getSearchParam("category") || [];
        angular.forEach(categoryService.getCategories(), function(category) {
            category.selected = categoryNamesInUrl.indexOf(category.name) !== -1;
        });
    }
    var categoryNamesInUrl = locationService.getSearchParam("category") || [];
    $scope.updateWithURL = function(e) {
        0 != categoryNamesInUrl.length && categoryNamesInUrl.indexOf(e.name) != -1 && (e.selected = !0);
    }, $scope.getCategories = function() {
        return categoryService.getCategories();
    }, $scope.shouldDisplayCategoryFilter = function() {
        return onRequisitionOrderPage($location.path()) && destinationIsSelected();
    }, $scope.$on("$locationChangeStart", function(event, newUrl) {
        $scope.shouldDisplayCategoryFilter && updateSelectedCategoriesFromUrl();
    }), $scope.onCategorySelected = function() {
        var selectedCategoryNames = [];
        angular.forEach(categoryService.getCategories(), function(category) {
            category.selected && selectedCategoryNames.push(category.name);
        }), locationService.setSearchParam("category", selectedCategoryNames, !0, !1);
    }, $scope.clearSelections = function() {
        angular.forEach(categoryService.getCategories(), function(cat) {
            cat.selected = !1;
        }), $scope.onCategorySelected();
    };
}

function locationAutocompleteService(appProps, locationApi, destinationApi) {
    var locations = [], locationCodes = [], codeToLocMap = new Map(), setLocations = function(response) {
        locations = response.result;
    }, setCodes = function() {
        angular.forEach(locations, function(loc) {
            locationCodes.push(loc.code + " (" + loc.locationDescription + ")");
        }), sortCodes(locationCodes);
    }, sortCodes = function(codes) {
        codes.sort(function(a, b) {
            return a < b ? -1 : a > b ? 1 : 0;
        });
    }, setCodesToLocationMap = function() {
        angular.forEach(locations, function(loc) {
            codeToLocMap.set(loc.code, loc);
        });
    }, reset = function() {
        locations = [], locationCodes = [], codeToLocMap = new Map();
    };
    return {
        initWithAllLocations: function() {
            return reset(), locationApi.get().$promise.then(setLocations).then(setCodes).then(setCodesToLocationMap);
        },
        initWithResponsibilityHeadLocations: function() {
            return reset(), destinationApi.get({
                empId: appProps.user.employeeId
            }).$promise.then(setLocations).then(setCodes).then(setCodesToLocationMap);
        },
        getCodes: function() {
            return locationCodes;
        },
        getCodeToLocationMap: function() {
            return codeToLocMap;
        },
        isValidCode: function(code) {
            return codeToLocMap.has(code);
        },
        getLocationFromCode: function(code) {
            return codeToLocMap.get(code);
        },
        getLocationAutocompleteOptions: function(height) {
            var autocompleteOptions = {
                options: {
                    html: !0,
                    focusOpen: !1,
                    onlySelectValid: !0,
                    outHeight: height || 300,
                    minLength: 0,
                    select: function(event, object) {
                        object.item.label = object.item.label.split("(")[0].trim(), object.item.value = object.item.value.split("(")[0].trim();
                    },
                    source: function(request, response) {
                        var data = locationCodes;
                        data = autocompleteOptions.methods.filter(data, request.term), data.length || data.push({
                            label: "Not Found",
                            value: ""
                        }), response(data);
                    },
                    messages: {
                        noResults: "",
                        results: function() {}
                    }
                },
                methods: {}
            };
            return autocompleteOptions;
        }
    };
}

function supplyCookieService($cookies, appProps) {
    function serializatize(cart) {
        return JSON.stringify(cart);
    }
    function deserialize(json) {
        return JSON.parse(json);
    }
    function encodeCart(cart) {
        return btoa(cart);
    }
    function decodeCart(s) {
        return atob(s);
    }
    var userId = appProps.user.employeeId;
    return {
        addCart: function(cart) {
            var code = encodeCart(serializatize(cart)), cur = $cookies.get(userId);
            null == cur && void 0 == cur || $cookies.remove(userId), $cookies.put(userId, code);
        },
        getCart: function() {
            var cur = $cookies.get(userId);
            return null == cur || void 0 == cur ? [] : deserialize(decodeCart(cur));
        },
        resetCart: function() {
            var cur = $cookies.get(userId);
            null == cur && void 0 == cur || $cookies.remove(userId);
        },
        addDestination: function(dist) {
            var key = "destination" + userId, cur = $cookies.get(key);
            null == cur && void 0 == cur || $cookies.remove(key), $cookies.put(key, serializatize(dist));
        },
        getDestination: function() {
            var key = "destination" + userId, cur = $cookies.get(key);
            return null == cur || void 0 == cur ? null : deserialize(cur);
        },
        resetDestination: function() {
            var key = "destination" + userId, cur = $cookies.get(key);
            null == cur && void 0 == cur || $cookies.remove(key);
        }
    };
}

function itemAutocompleteService(itemsApi) {
    var items = [], commodityCodes = [], commodityCodesToItems = new Map(), setItems = function(response) {
        items = response.result;
    }, setCommodityCodes = function() {
        angular.forEach(items, function(item) {
            commodityCodes.push(item.commodityCode);
        });
    }, setCommodityCodesToItems = function() {
        angular.forEach(items, function(item) {
            commodityCodesToItems.set(item.commodityCode, item);
        });
    }, reset = function() {
        items = [], commodityCodes = [], commodityCodesToItems = new Map();
    };
    return {
        initWithAllItems: function() {
            return reset(), itemsApi.get().$promise.then(setItems).then(setCommodityCodes).then(setCommodityCodesToItems);
        },
        getItemFromCommodityCode: function(commodityCode) {
            return commodityCodesToItems.get(commodityCode);
        },
        getItemAutocompleteOptions: function() {
            var autocompleteOptions = {
                options: {
                    html: !0,
                    focusOpen: !1,
                    onlySelectValid: !0,
                    outHeight: 50,
                    minLength: 0,
                    source: function(request, response) {
                        var data = commodityCodes;
                        data = autocompleteOptions.methods.filter(data, request.term), data.length || data.push({
                            label: "Not Found",
                            value: ""
                        }), response(data);
                    },
                    messages: {
                        noResults: "",
                        results: function() {}
                    }
                },
                methods: {}
            };
            return autocompleteOptions;
        }
    };
}

function supplyHistoryController($scope, supplyEmployeesApi, requisitionApi, locationService, locationApi, paginationModel, supplyUtils) {
    function getUpdatedOrders() {
        var params = {
            status: [ "APPROVED", "REJECTED" ],
            from: moment($scope.filter.date.from).startOf("day").format(),
            to: moment($scope.filter.date.to).endOf("day").format(),
            limit: $scope.paginate.itemsPerPage,
            offset: $scope.paginate.getOffset(),
            location: $scope.selectedLocation,
            issuerId: $scope.issuerNameToID[$scope.selectedIssuer]
        };
        return requisitionApi.get(params, function(response) {
            $scope.shipments = response.result, $scope.paginate.setTotalItems(response.total);
        }, function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }
    function initFilters() {
        locationApi.get().$promise.then(setLocations), supplyEmployeesApi.get().$promise.then(setIssuers);
    }
    function doneLoading() {
        $scope.loading = !1;
    }
    $scope.paginate = angular.extend({}, paginationModel), $scope.loading = !0, $scope.shipments = null, 
    $scope.locations = [], $scope.selectedIssuer = null, $scope.issuers = [], $scope.issuerNameToID = [], 
    $scope.filter = {
        date: {
            from: moment().subtract(1, "month").format("MM/DD/YYYY"),
            to: moment().format("MM/DD/YYYY")
        }
    }, $scope.init = function() {
        $scope.paginate.itemsPerPage = 12, getUpdatedOrders().$promise.then(initFilters).then(doneLoading);
    }, $scope.init(), $scope.onFilterChange = function() {
        $scope.loading = !0, $scope.paginate.reset(), getUpdatedOrders().$promise.then(doneLoading).catch(function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }, $scope.onPageChange = function() {
        $scope.loading = !0, getUpdatedOrders().$promise.then(doneLoading).catch(function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    };
    var setLocations = function(response) {
        response.result.forEach(function(e) {
            $scope.locations.push(e.locId);
        }), sortCodes($scope.locations), $scope.locations.unshift("All"), $scope.selectedLocation = $scope.locations[0];
    }, setIssuers = function(response) {
        response.result.forEach(function(e) {
            $scope.issuers.push(e.fullName), $scope.issuerNameToID[e.fullName] = e.employeeId;
        }), $scope.issuers.unshift("All"), $scope.selectedIssuer = $scope.issuers[0];
    }, sortCodes = function(codes) {
        codes.sort(function(a, b) {
            return a < b ? -1 : a > b ? 1 : 0;
        });
    };
    $scope.distinctItemQuantity = function(requisition) {
        return supplyUtils.countDistinctItemsInRequisition(requisition);
    }, $scope.viewRequisition = function(shipment) {
        locationService.go("/supply/requisition/requisition-view", !1, "requisition=" + shipment.requisitionId + "&fromPage=requisitionhistory");
    };
}

function supplyOrderHistoryCtrl($scope, appProps, locationService, empInfoApi, orderHistoryApi, paginationModel) {
    function queryOrderHistory() {
        return getLoggedInEmployeeInfo().then(getRequisitions).then(setRequisitions).finally(doneLoading).catch(function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }
    function getLoggedInEmployeeInfo() {
        var params = {
            empId: appProps.user.employeeId,
            detail: !0
        };
        return empInfoApi.get(params).$promise.catch(function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }
    function getRequisitions(employeeInfoResponse) {
        $scope.filter.status.indexOf("ALL") != -1 && ($scope.filter.status = angular.copy($scope.STATUSES.slice(1)));
        var params = {
            location: employeeInfoResponse.employee.empWorkLocation.locId,
            customerId: employeeInfoResponse.employee.employeeId,
            status: $scope.filter.status,
            from: moment($scope.filter.date.from, DATE_FORMAT).startOf("day").format(),
            to: moment($scope.filter.date.to, DATE_FORMAT).endOf("day").format(),
            limit: $scope.paginate.itemsPerPage,
            offset: $scope.paginate.getOffset()
        };
        return orderHistoryApi.get(params, function(response) {
            $scope.paginate.setTotalItems(response.total);
        }, function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        }).$promise;
    }
    function setRequisitions(orderHistoryResponse) {
        return $scope.requisitions = orderHistoryResponse.result, $scope.requisitions;
    }
    function doneLoading() {
        $scope.loading = !1;
    }
    var DATE_FORMAT = "MM/DD/YYYY";
    $scope.STATUSES = [ "ALL", "PENDING", "PROCESSING", "COMPLETED", "APPROVED", "REJECTED" ], 
    $scope.requisitions = [], $scope.paginate = angular.extend({}, paginationModel), 
    $scope.filter = {
        date: {
            from: moment().subtract(1, "month").format(DATE_FORMAT),
            to: moment().format(DATE_FORMAT)
        },
        status: []
    }, $scope.loading = !0, $scope.init = function() {
        $scope.paginate.itemsPerPage = 12, $scope.filter.status = angular.copy($scope.STATUSES.slice(1)), 
        queryOrderHistory();
    }, $scope.init(), $scope.updateRequisitions = function() {
        $scope.loading = !0, queryOrderHistory();
    }, $scope.viewRequisition = function(requisition) {
        locationService.go("/supply/requisition/requisition-view", !1, "requisition=" + requisition.requisitionId + "&fromPage=orderhistory");
    };
}

function supplyFulfillmentController($scope, requisitionApi, supplyEmployeesApi, itemsApi, modals, $interval, locationService, locationStatisticsService, supplyUtils) {
    function updateShipments() {
        getPendingShipments(), getProcessingShipments(), getCompletedShipments(), getApprovedShipments(), 
        getSyncFailedShipments(), getCanceledShipments();
    }
    function getSupplyEmployees() {
        supplyEmployeesApi.get(function(response) {
            $scope.supplyEmployees = response.result;
        }, function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }
    function getLocationStatistics() {
        var year = moment().year(), month = moment().month() + 1;
        locationStatisticsService.calculateLocationStatisticsFor(year, month).then(function(result) {
            $scope.locationStatistics = result;
        }).catch(function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }
    function getPendingShipments() {
        var params = {
            status: "PENDING",
            from: moment.unix(1).format()
        };
        $scope.pendingSearch.response = requisitionApi.get(params, function(response) {
            $scope.pendingSearch.matches = response.result, $scope.pendingSearch.error = !1;
        }, function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }
    function getProcessingShipments() {
        var params = {
            status: "PROCESSING",
            from: moment.unix(1).format()
        };
        $scope.processingSearch.response = requisitionApi.get(params, function(response) {
            $scope.processingSearch.matches = response.result, $scope.processingSearch.error = !1;
        }, function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }
    function getCompletedShipments() {
        var params = {
            status: "COMPLETED",
            from: moment.unix(1).format()
        };
        $scope.completedSearch.response = requisitionApi.get(params, function(response) {
            $scope.completedSearch.matches = response.result, $scope.completedSearch.error = !1;
        }, function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }
    function getApprovedShipments() {
        var params = {
            status: "APPROVED",
            from: moment().startOf("day").format(),
            dateField: "approved_date_time"
        };
        $scope.approvedSearch.response = requisitionApi.get(params, function(response) {
            $scope.approvedSearch.matches = response.result, $scope.approvedSearch.error = !1;
        }, function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }
    function getSyncFailedShipments() {
        var params = {
            status: "APPROVED",
            savedInSfms: !1
        };
        $scope.syncFailedSearch.response = requisitionApi.get(params, function(response) {
            $scope.syncFailedSearch.matches = response.result, $scope.syncFailedSearch.matches = removeNewPlaceReq($scope.syncFailedSearch.matches), 
            $scope.syncFailedSearch.error = !1;
        }, function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }
    function removeNewPlaceReq(input) {
        var result = [];
        return input.forEach(function(ele) {
            null != ele.lastSfmsSyncDateTime && result.push(ele);
        }), result;
    }
    function getCanceledShipments() {
        var params = {
            status: "REJECTED",
            from: moment().startOf("day").format(),
            dateField: "rejected_date_time"
        };
        $scope.canceledSearch.response = requisitionApi.get(params, function(response) {
            $scope.canceledSearch.matches = response.result, $scope.canceledSearch.error = !1;
        }, function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }
    function isOverPerOrderMax(requisition) {
        var isOverPerOrderMax = !1;
        return angular.forEach(requisition.lineItems, function(lineItem) {
            lineItem.quantity > lineItem.item.maxQtyPerOrder && (isOverPerOrderMax = !0);
        }), isOverPerOrderMax;
    }
    function containsSpecialItems(requisition) {
        var containsSpecialItems = !1;
        return angular.forEach(requisition.lineItems, function(lineItem) {
            "SPECIAL" === lineItem.item.visibility && (containsSpecialItems = !0);
        }), containsSpecialItems;
    }
    function isOverPerMonthMax(requisition) {
        if (null == $scope.locationStatistics) return !1;
        var isOverPerMonthMax = !1;
        return angular.forEach(requisition.lineItems, function(lineItem) {
            var monthToDateQty = $scope.locationStatistics.getQuantityForLocationAndItem(requisition.destination.locId, lineItem.item.commodityCode);
            monthToDateQty > lineItem.item.suggestedMaxQty && (isOverPerMonthMax = !0);
        }), isOverPerMonthMax;
    }
    function successfulSave(response) {
        locationService.go("/supply/manage/fulfillment", !0);
    }
    function errorSaving(response) {
        void 0 !== response && 409 === response.status && ($scope.saveResponse = response, 
        $scope.saveResponse.error = !0, modals.open("500", {
            details: response
        }));
    }
    $scope.pendingSearch = {
        matches: [],
        response: {},
        error: !1
    }, $scope.processingSearch = {
        matches: [],
        response: {},
        error: !1
    }, $scope.completedSearch = {
        matches: [],
        response: {},
        error: !1
    }, $scope.approvedSearch = {
        matches: [],
        response: {},
        error: !1
    }, $scope.syncFailedSearch = {
        matches: [],
        response: {},
        error: !1
    }, $scope.canceledSearch = {
        matches: [],
        response: {},
        error: !1
    }, $scope.saveResponse = {
        response: {},
        error: !1
    }, $scope.supplyEmployees = [], $scope.locationStatistics = null, $scope.init = function() {
        updateShipments(), getSupplyEmployees(), getLocationStatistics();
    }, $scope.init();
    var intervalPromise = $interval(function() {
        updateShipments();
    }, 6e4);
    $scope.$on("$destroy", function() {
        $interval.cancel(intervalPromise);
    }), $scope.distinctItemQuantity = function(requisition) {
        return supplyUtils.countDistinctItemsInRequisition(requisition);
    }, $scope.calculateHighlighting = function(requisition) {
        return {
            warn: isOverPerOrderMax(requisition) || isOverPerMonthMax(requisition) || containsSpecialItems(requisition),
            bold: isOverPerMonthMax(requisition)
        };
    }, $scope.showEditingModal = function(requisition) {
        $scope.saveResponse.response = modals.open("fulfillment-editing-modal", requisition).then(successfulSave).catch(errorSaving);
    }, $scope.showImmutableModal = function(requisition) {
        modals.open("fulfillment-immutable-modal", requisition);
    };
}

function supplyReconciliationController($scope, supplyReconciliationApi, requisitionApi, locationService, $window, $timeout) {
    function initItems() {
        supplyReconciliationApi.get().$promise.then(function(response) {
            response.result.forEach(function(item) {
                $scope.reconciliations[item.item_category] = item.page;
            });
            var params = {
                status: "APPROVED",
                from: moment().startOf("day").format(),
                to: moment().format(),
                dateField: "approved_date_time"
            };
            $scope.reconcilableSearch.response = requisitionApi.get(params, function(response) {
                $scope.reconcilableSearch.matches = response.result, $scope.reconcilableSearch.error = !1, 
                angular.forEach($scope.reconcilableSearch.matches, function(shipment) {
                    angular.forEach(shipment.lineItems, function(lineItem) {
                        $scope.reconcilableItemMap.hasOwnProperty(lineItem.item.id) ? $scope.reconcilableItemMap[lineItem.item.id].push(shipment) : ($scope.reconcilableItemMap[lineItem.item.id] = [], 
                        $scope.reconcilableItemMap[lineItem.item.id].push(shipment), lineItem.item.page = $scope.reconciliations[lineItem.item.category.name], 
                        $scope.reconcilableSearch.items.push(lineItem.item));
                    });
                });
            }, function(response) {
                $scope.reconcilableSearch.matches = [], $scope.reconcilableSearch.items = [], $scope.reconcilableSearch.error = !0, 
                modals.open("500", {
                    details: response
                });
            });
        });
    }
    $scope.selectedItem = null, $scope.viewItems = [], $scope.reconcilableSearch = {
        matches: [],
        items: [],
        response: {},
        error: !1
    }, $scope.currentPage = 1, $scope.reconciliations = {}, $scope.reconcilableItemMap = {}, 
    $scope.print = function() {
        $timeout($window.print, 0);
    }, $scope.setSelected = function(item) {
        $scope.selectedItem == item ? $scope.selectedItem = null : $scope.selectedItem = item;
    }, $scope.isItemSelected = function(item) {
        return $scope.selectedItem == item;
    }, $scope.getShipmentsWithItem = function(item) {
        return $scope.reconcilableItemMap[item.id];
    }, $scope.getOrderedQuantity = function(shipment, item) {
        for (var lineItems = shipment.lineItems, i = 0; i < lineItems.length; i++) if (lineItems[i].item.id === item.id) return lineItems[i].quantity;
    }, $scope.viewShipment = function(shipment) {
        locationService.go("/supply/requisition/requisition-view", !1, "requisition=" + shipment.requisitionId + "&fromPage=reconciliation");
    }, $scope.init = function() {
        initItems();
    }, $scope.setCurrentPage = function(e) {
        $("#page" + $scope.currentPage).css("text-decoration", ""), $scope.currentPage = e, 
        $("#page" + $scope.currentPage).css("text-decoration", "underline");
    }, $scope.init();
}

function fulfillmentEditingModal($scope, appProps, modals, requisitionApi, locationAutocompleteService, itemAutocompleteService) {
    function setIssuerToLoggedInUser() {
        angular.forEach($scope.supplyEmployees, function(emp) {
            emp.employeeId === appProps.user.employeeId && ($scope.editableRequisition.issuer = emp);
        });
    }
    function isOverPerOrderMax(lineItem) {
        return lineItem.quantity > lineItem.item.maxQtyPerOrder;
    }
    function containsSpecialItems(lineItem) {
        return "SPECIAL" === lineItem.item.visibility;
    }
    function isOverPerMonthMax(lineItem) {
        if (null == $scope.locationStatistics) return !1;
        var monthToDateQty = $scope.locationStatistics.getQuantityForLocationAndItem($scope.originalRequisition.destination.locId, lineItem.item.commodityCode);
        return monthToDateQty > lineItem.item.suggestedMaxQty;
    }
    function isItemADuplicate(newItem) {
        var duplicateItem = !1;
        return angular.forEach($scope.editableRequisition.lineItems, function(lineItem) {
            newItem.id === lineItem.item.id && (duplicateItem = !0);
        }), duplicateItem;
    }
    $scope.dirty = !1, $scope.originalRequisition = {}, $scope.editableRequisition = {}, 
    $scope.newLocationCode = "", $scope.newItemCommodityCode = "", $scope.displayRejectInstructions = !1, 
    $scope.init = function() {
        $scope.originalRequisition = modals.params(), $scope.originalRequisition.note = "", 
        $scope.editableRequisition = angular.copy($scope.originalRequisition), $scope.newLocationCode = $scope.editableRequisition.destination.code, 
        itemAutocompleteService.initWithAllItems();
    }, $scope.init(), $scope.saveChanges = function() {
        requisitionApi.save({
            id: $scope.originalRequisition.requisitionId
        }, $scope.editableRequisition).$promise.then(function() {
            modals.resolve();
        }, function(errorResponse) {
            modals.open("500", {
                details: errorResponse
            });
        });
    }, $scope.closeModal = function() {
        modals.reject();
    }, $scope.processOrder = function() {
        $scope.editableRequisition.status = "PROCESSING", $scope.editableRequisition.processedDateTime = moment().format("YYYY-MM-DDTHH:mm:ss.SSS"), 
        null === $scope.editableRequisition.issuer && setIssuerToLoggedInUser(), $scope.saveChanges();
    }, $scope.completeOrder = function() {
        $scope.editableRequisition.status = "COMPLETED", $scope.editableRequisition.completedDateTime = moment().format("YYYY-MM-DDTHH:mm:ss.SSS"), 
        $scope.saveChanges();
    }, $scope.selfApprove = !1, $scope.approveShipment = function() {
        return appProps.user.employeeId === $scope.originalRequisition.customer.employeeId ? void ($scope.selfApprove = !0) : ($scope.selfApprove = !1, 
        $scope.editableRequisition.status = "APPROVED", $scope.editableRequisition.approvedDateTime = moment().format("YYYY-MM-DDTHH:mm:ss.SSS"), 
        void $scope.saveChanges());
    }, $scope.rejectOrder = function() {
        $scope.originalRequisition.note === $scope.editableRequisition.note ? $scope.displayRejectInstructions = !0 : ($scope.editableRequisition.status = "REJECTED", 
        $scope.editableRequisition.rejectedDateTime = moment().format("YYYY-MM-DDTHH:mm:ss.SSS"), 
        $scope.saveChanges());
    }, $scope.onUpdate = function() {
        $scope.dirty = angular.toJson($scope.originalRequisition) !== angular.toJson($scope.editableRequisition);
    }, $scope.onLocationUpdated = function() {
        var loc = locationAutocompleteService.getLocationFromCode($scope.newLocationCode);
        loc ? $scope.editableRequisition.destination = loc : $scope.editableRequisition.destination = $scope.originalRequisition.destination, 
        $scope.onUpdate();
    }, $scope.getLocationAutocompleteOptions = function() {
        return locationAutocompleteService.getLocationAutocompleteOptions(100);
    }, $scope.calculateHighlighting = function(lineItem) {
        return {
            warn: isOverPerOrderMax(lineItem) || isOverPerMonthMax(lineItem) || containsSpecialItems(lineItem),
            bold: isOverPerMonthMax(lineItem)
        };
    }, $scope.highlightLineItem = function(lineItem) {
        return lineItem.quantity > lineItem.item.suggestedMaxQty || "SPECIAL" === lineItem.item.visibility;
    }, $scope.warning = !1, $scope.addItem = function() {
        var newItem = itemAutocompleteService.getItemFromCommodityCode($scope.newItemCommodityCode);
        return !!newItem && (isItemADuplicate(newItem) ? void ($scope.warning = !0) : ($scope.warning = !1, 
        $scope.editableRequisition.lineItems.push({
            item: newItem,
            quantity: 1
        }), $scope.newItemCommodityCode = "", void $scope.onUpdate()));
    }, $scope.getItemAutocompleteOptions = function() {
        return itemAutocompleteService.getItemAutocompleteOptions();
    };
}

function supplyOrderController($scope, appProps, locationService, supplyCart, paginationModel, locationAutocompleteService, allowanceService, destinationService, modals, supplyUtils) {
    function loadSelectDestinationState() {
        locationAutocompleteService.initWithResponsibilityHeadLocations().then(destinationService.queryDefaultDestination).then(setDestinationCode).then(setToSelectingDestinationState).catch(loadDestinationsError);
    }
    function setDestinationCode() {
        $scope.destinationCode = destinationService.getDefaultCode();
    }
    function setDestinationDescription() {
        $scope.destinationDescription = destinationService.getDestination().locationDescription || "";
    }
    function setToSelectingDestinationState() {
        $scope.state = $scope.states.SELECTING_DESTINATION;
    }
    function loadDestinationsError(response) {
        modals.open("500", {
            action: "get valid order destinations",
            details: response
        });
    }
    function loadShoppingState() {
        $scope.state = $scope.states.LOADING, $scope.destinationCode = destinationService.getDestination().code, 
        allowanceService.queryLocationAllowance(destinationService.getDestination()).then(saveAllowances).then(filterAllowances).then(setAllowances).then(setToShoppingState).then(setDestinationDescription).then(checkSortOrder).catch(loadItemsError);
    }
    function saveAllowances(allowanceResponse) {
        allowances = allowanceResponse.result.itemAllowances;
    }
    function filterAllowances() {
        $scope.displayAllowances = allowanceService.filterAllowances(allowances, $scope.filter.categories, $scope.filter.searchTerm), 
        $scope.displayAllowances = supplyUtils.alphabetizeAllowances($scope.displayAllowances);
    }
    function setAllowances() {
        supplyCart.getCart().length > 0 && supplyCart.getCart().forEach(function(item) {
            $scope.displayAllowances.forEach(function(allowance) {
                item.item.id == allowance.item.id && item.quantity > allowance.item.maxQtyPerOrder && (allowance.selectedQuantity = "more");
            });
        });
    }
    function setToShoppingState() {
        $scope.state = $scope.states.SHOPPING;
    }
    function checkSortOrder(allowance) {
        $scope.updateSort();
    }
    function loadItemsError(response) {
        modals.open("500", {
            action: "get supply items",
            details: response
        });
    }
    function Reset() {
        $scope.filter.searchTerm = "", filterAllowances();
    }
    function updateFiltersFromUrlParams() {
        $scope.filter.categories = locationService.getSearchParam("category") || [], $scope.paginate.currPage = locationService.getSearchParam("page") || 1, 
        locationService.setSearchParam("page", $scope.paginate.currPage, !0, !0);
    }
    $scope.state = {}, $scope.sorting = {
        Name: 0,
        Category: 10
    }, $scope.sortBy = $scope.sorting.Alphabet, $scope.states = {
        LOADING: 0,
        SELECTING_DESTINATION: 5,
        SHOPPING: 10
    }, $scope.displaySorting = Object.getOwnPropertyNames($scope.sorting), $scope.paginate = angular.extend({}, paginationModel), 
    $scope.filter = {
        searchTerm: "",
        categories: []
    };
    var allowances = [];
    $scope.displayAllowances = [], $scope.destinationCode = "", $scope.destinationDescription = "", 
    $scope.init = function() {
        $scope.state = $scope.states.LOADING, $scope.paginate.itemsPerPage = 16, updateFiltersFromUrlParams(), 
        destinationService.isDestinationConfirmed() ? loadShoppingState() : loadSelectDestinationState();
    }, $scope.init(), $scope.search = function() {
        filterAllowances();
    }, $scope.reset = function() {
        Reset();
    }, $scope.onPageChange = function() {
        locationService.setSearchParam("page", $scope.paginate.currPage, !0, !1);
    }, $scope.$on("$locationChangeStart", function(event, newUrl) {
        newUrl.indexOf(appProps.ctxPath + "/supply/order") > -1 && (updateFiltersFromUrlParams(), 
        filterAllowances());
    }), $scope.addToCart = function(allowance) {
        return "more" === allowance.selectedQuantity || 0 == $scope.getItemRemainQuantities(allowance.item) ? void $scope.quantityChanged(allowance) : void (isNaN(allowance.selectedQuantity) || supplyCart.isOverOrderAllowance(allowance.item, allowance.selectedQuantity) || (supplyCart.isItemInCart(allowance.item.id) || "SPECIAL" !== allowance.visibility ? supplyCart.addToCart(allowance.item, allowance.selectedQuantity) : modals.open("special-order-item-modal", {
            allowance: allowance
        })));
    }, $scope.isInCart = function(item) {
        return supplyCart.isItemInCart(item.id);
    }, $scope.getItemQuantity = function(item) {
        return supplyCart.isItemInCart(item.id) ? supplyCart.getCartLineItem(item.id).quantity : 0;
    }, $scope.getItemAllowedQuantities = function(item) {
        return allowanceService.getAllowedQuantities(item).slice(-1)[0];
    }, $scope.getItemTestSpecialOrder = function(item) {
        return $scope.getItemAllowedQuantities(item) < $scope.getItemQuantity(item) ? "Yes" : "No";
    }, $scope.getItemRemainQuantities = function(item) {
        return $scope.getItemAllowedQuantities(item) - $scope.getItemQuantity(item) >= 0 || "SPECIAL" === item.visibility ? $scope.getItemAllowedQuantities(item) - $scope.getItemQuantity(item) : 0;
    }, $scope.getAllowedQuantities = function(item) {
        var allowedQuantities = allowanceService.getAllowedQuantities(item);
        return allowedQuantities.push("more"), allowedQuantities;
    }, $scope.quantityChanged = function(allowance) {
        "more" !== allowance.selectedQuantity && 0 != $scope.getItemRemainQuantities(allowance.item) || modals.open("order-more-prompt-modal", {
            allowance: allowance
        }).then(function(allowance) {
            modals.open("order-custom-quantity-modal", {
                item: allowance.item
            });
        });
    }, $scope.confirmDestination = function() {
        var success = destinationService.setDestination($scope.destinationCode);
        success && loadShoppingState();
    }, $scope.$on("$locationChangeStart", function(event, newUrl) {
        $scope.updateSort();
    }), $scope.getLocationAutocompleteOptions = function() {
        return locationAutocompleteService.getLocationAutocompleteOptions();
    }, $scope.resetDestination = function(body) {
        supplyCart.getCart().length > 0 ? modals.open("order-canceling-modal") : (destinationService.reset(), 
        locationService.go("/supply/order", !0));
    }, $scope.backHidden = function() {
        return $scope.state == $scope.states.SELECTING_DESTINATION;
    }, $scope.updateSort = function() {
        var cur = locationService.getSearchParam("sortBy") || [];
        0 != cur.length && cur[0] == $scope.sortBy || locationService.setSearchParam("sortBy", $scope.sortBy, !0, !1);
        var allowancesCopy = angular.copy($scope.displayAllowances);
        $scope.sorting[$scope.sortBy] == $scope.sorting.Name ? allowancesCopy.sort(function(a, b) {
            return a.item.description < b.item.description ? -1 : a.item.description > b.item.description ? 1 : 0;
        }) : $scope.sorting[$scope.sortBy] == $scope.sorting.Category && allowancesCopy.sort(function(a, b) {
            return a.item.category.name < b.item.category.name ? -1 : a.item.category.name > b.item.category.name ? 1 : 0;
        }), $scope.displayAllowances = allowancesCopy;
    };
}

function locationAllowanceService(allowanceApi) {
    function filterAllowancesByCategories(allowances, categories) {
        if (0 === categories.length) return allowances;
        var filtered = [];
        return angular.forEach(allowances, function(allowance) {
            categories.indexOf(allowance.item.category.name) !== -1 && filtered.push(allowance);
        }), filtered;
    }
    function filterAllowancesBySearch(allowances, searchTerm) {
        var filtered = [];
        return angular.forEach(allowances, function(allowance) {
            allowance.item.description.indexOf(searchTerm.toUpperCase()) !== -1 && filtered.push(allowance);
        }), filtered;
    }
    var allowances = null;
    return {
        queryLocationAllowance: function(location) {
            return allowanceApi.get({
                id: location.locId
            }, function(response) {
                allowances = response.result.itemAllowances;
            }).$promise;
        },
        filterAllowances: function(allowances, categories, searchTerm) {
            var filteredAllowances = angular.copy(allowances);
            return void 0 !== categories && null !== categories && categories.length > 0 && (filteredAllowances = filterAllowancesByCategories(filteredAllowances, categories)), 
            void 0 !== searchTerm && null !== searchTerm && searchTerm.length > 0 && (filteredAllowances = filterAllowancesBySearch(filteredAllowances, searchTerm)), 
            filteredAllowances;
        },
        getAllowances: function() {
            return allowances;
        },
        getAllowedQuantities: function(item) {
            item.maxQtyPerOrder > 50 && (item.maxQtyPerOrder = 50);
            for (var range = [], i = 1; i <= item.maxQtyPerOrder; i++) range.push(i);
            return range;
        }
    };
}

function orderDestinationService(appProps, cookies, empInfoApi, locationAutocompleteService) {
    var defaultCode = void 0;
    return {
        queryDefaultDestination: function() {
            if (!defaultCode) return empInfoApi.get({
                empId: appProps.user.employeeId,
                detail: !0
            }, function(response) {
                defaultCode = response.employee.empWorkLocation.code;
            }).$promise;
        },
        isDestinationConfirmed: function() {
            return null !== cookies.getDestination() && void 0 !== cookies.getDestination();
        },
        setDestination: function(code) {
            return !!locationAutocompleteService.isValidCode(code) && (cookies.addDestination(locationAutocompleteService.getLocationFromCode(code)), 
            !0);
        },
        reset: function() {
            defaultCode = void 0, cookies.resetDestination();
        },
        getDefaultCode: function() {
            return defaultCode;
        },
        getDestination: function() {
            return cookies.getDestination();
        }
    };
}

function supplyCartController($scope, cookies, supplyCart, allowanceService, requisitionApi, destinationService, appProps, modals, locationService) {
    $scope.destinationCode = null, $scope.destinationDescription = "", $scope.specialInstructions = null, 
    $scope.init = function() {
        var destination = destinationService.getDestination();
        null != destination && ($scope.destinationCode = destination.code, $scope.destinationDescription = destination.locationDescription || "");
    }, $scope.init(), $scope.myCartItems = function() {
        return supplyCart.getCart();
    }, $scope.orderQuantityRange = function(item) {
        return allowanceService.getAllowedQuantities(item);
    }, $scope.cartHasItems = function() {
        return supplyCart.getCart().length > 0;
    }, $scope.removeFromCart = function(item) {
        supplyCart.removeFromCart(item.id);
    }, $scope.submitOrder = function() {
        var params = {
            customerId: appProps.user.employeeId,
            lineItems: supplyCart.getCart(),
            destinationId: cookies.getDestination().locId,
            specialInstructions: $scope.specialInstructions
        };
        requisitionApi.save(params, function(response) {
            supplyCart.reset(), modals.open("supply-cart-checkout-modal", response);
        }, function(response) {
            modals.open("500", {
                action: "checkout cart",
                details: response
            });
        });
    }, $scope.orderedOverPerOrderMax = function(cartItem) {
        return cartItem.quantity > cartItem.item.maxQtyPerOrder;
    }, $scope.closeModal = function() {
        modals.resolve();
    }, $scope.returnToSupply = function() {
        modals.resolve(), locationService.go("/supply/order", !1);
    }, $scope.resetDestination = function() {
        supplyCart.reset(), destinationService.reset(), locationService.go("/supply/order", !1);
    }, $scope.emptyCart = function() {
        supplyCart.reset();
    }, $scope.logout = function() {
        locationService.go("/logout", !0);
    };
}

function supplyViewController($scope, historyApi, locationService, $window, $timeout, supplyUtils) {
    function generateVersions() {
        for (var k in $scope.shipment) $scope.shipment.hasOwnProperty(k) && $scope.requisitionHistory.versions.push($scope.shipment[k]);
    }
    function generateVersionNames() {
        for (var i = 0; i < $scope.requisitionHistory.versions.length; i++) 0 === i ? $scope.requisitionHistory.versions[i].name = "Original" : i === $scope.requisitionHistory.versions.length - 1 ? $scope.requisitionHistory.versions[i].name = "Current" : $scope.requisitionHistory.versions[i].name = i + 1;
    }
    $scope.requisitionResponse = {}, $scope.requisitionHistory = {
        versions: []
    }, $scope.selectedVersion = {}, $scope.shipemnt = {}, $scope.init = function() {
        var fromPage = locationService.getSearchParam("fromPage");
        highlightMenu(fromPage);
        var id = locationService.getSearchParam("requisition");
        $scope.requisitionResponse = historyApi.get({
            id: id
        }), $scope.requisitionResponse.$promise.then(extractShipment).then(printIfRequested).then(generateHistory).then(selectCurrentVersion).catch(shipmentResourceErrorHandler);
    };
    var highlightMenu = function(fromPage) {
        $(".sub-topic").removeClass("active"), $(".sub-topic").toArray().forEach(function(t) {
            t.textContent.toLowerCase().replace(/\s/g, "").indexOf(fromPage) != -1 && t.classList.add("active");
        });
    }, extractShipment = function(response) {
        $scope.shipment = response.result;
    }, printIfRequested = function() {
        var print = locationService.getSearchParam("print");
        "true" === print && $timeout(function() {
            $window.print();
        });
    }, generateHistory = function() {
        generateVersions(), generateVersionNames(), $scope.requisitionHistory.versions.reverse();
    }, selectCurrentVersion = function() {
        $scope.selectedVersion = $scope.requisitionHistory.versions[0];
    }, shipmentResourceErrorHandler = function(response) {};
    $scope.init(), $scope.sortSelectedVersionLineItems = function() {
        if ($scope.selectedVersion && $scope.selectedVersion.lineItems) return supplyUtils.alphabetizeLineItems($scope.selectedVersion.lineItems);
    }, $scope.displayIssuedDate = function(selectedVersion) {
        return "COMPLETED" === selectedVersion.status || "APPROVED" === selectedVersion.status;
    };
}

function supplyLocationStatisticsService($q, locationStatisticsApi) {
    function LocationStatistics(locationStatistcsMap) {
        this.locationStatisticsMap = locationStatistcsMap, this.getQuantityForLocationAndItem = function(location, item) {
            return locationStatistcsMap[location].itemQuantities[item];
        };
    }
    return {
        calculateLocationStatisticsFor: function(year, month) {
            return $q(function(resolve, reject) {
                var params = {
                    year: year,
                    month: month
                };
                locationStatisticsApi.get(params, function(response) {
                    resolve(new LocationStatistics(response.result.items));
                });
            });
        }
    };
}

var essSupply = angular.module("essSupply").controller("SupplyNavigationController", [ "$scope", "$location", "appProps", "LocationService", "SupplyCategoryService", "SupplyOrderDestinationService", supplyNavigationController ]), essSupply = angular.module("essSupply");

essSupply.service("SupplyInventoryService", [ "SupplyItemsApi", function(supplyItemsApi) {
    var items = [], promise = !1;
    return supplyItemsApi.get(function(response) {
        items = response.result, promise = !0;
    }), {
        promise: promise,
        getCopyOfItems: function() {
            return angular.copy(items);
        },
        orderQuantityRange: function(item) {
            for (var range = [], i = 1; i <= 2 * item.suggestedMaxQty; i++) range.push(i);
            return range;
        },
        getCartLineItem: function(id) {
            var item = !1, search = $.grep(items, function(prod) {
                return prod.id === id;
            });
            return search.length > 0 && (item = search[0]), item;
        }
    };
} ]);

var essSupply = angular.module("essSupply");

essSupply.service("SupplyCategoryService", [ "SupplyLocationAllowanceService", "SupplyOrderDestinationService", function(locationAllowanceService, destinationService) {
    function Category(name) {
        this.name = name, this.selected = !1;
    }
    function isDistinctCategory(name) {
        var cats = $.grep(categories, function(cat) {
            return cat.name === name;
        });
        return !cats.length > 0;
    }
    var categories = [], initCategories = function() {
        var allowances = locationAllowanceService.getAllowances();
        null !== allowances && (angular.forEach(allowances, function(allowance) {
            isDistinctCategory(allowance.item.category.name) && categories.push(new Category(allowance.item.category.name));
        }), categories.sort(function(a, b) {
            return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
        }));
    };
    return {
        getCategories: function() {
            return null !== categories && 0 !== categories.length || initCategories(), categories;
        },
        getSelectedCategoryNames: function() {
            var selected = [];
            return angular.forEach(categories, function(cat) {
                cat.selected === !0 && selected.push(cat.name);
            }), selected;
        }
    };
} ]), angular.module("essSupply").service("SupplyLocationAutocompleteService", [ "appProps", "LocationApi", "SupplyDestinationApi", locationAutocompleteService ]);

var essSupply = angular.module("essSupply");

essSupply.service("SupplyCookieService", [ "$cookies", "appProps", supplyCookieService ]), 
angular.module("essSupply").service("SupplyItemAutocompleteService", [ "SupplyItemsApi", itemAutocompleteService ]), 
essSupply = angular.module("essSupply").controller("SupplyHistoryController", [ "$scope", "SupplyEmployeesApi", "SupplyRequisitionApi", "LocationService", "LocationApi", "PaginationModel", "SupplyUtils", supplyHistoryController ]);

var essSupply = angular.module("essSupply").controller("SupplyOrderHistoryCtrl", [ "$scope", "appProps", "LocationService", "EmpInfoApi", "SupplyRequisitionOrderHistoryApi", "PaginationModel", supplyOrderHistoryCtrl ]);

essSupply = angular.module("essSupply").controller("SupplyFulfillmentController", [ "$scope", "SupplyRequisitionApi", "SupplyEmployeesApi", "SupplyItemsApi", "modals", "$interval", "LocationService", "SupplyLocationStatisticsService", "SupplyUtils", supplyFulfillmentController ]), 
essSupply = angular.module("essSupply").controller("SupplyReconciliationController", [ "$scope", "SupplyReconciliationApi", "SupplyRequisitionApi", "LocationService", "$window", "$timeout", supplyReconciliationController ]);

var essSupply = angular.module("essSupply").directive("fulfillmentEditingModal", [ "appProps", function(appProps) {
    return {
        templateUrl: appProps.ctxPath + "/template/supply/manage/fulfillment/modal/fulfillment-editing-modal",
        scope: {
            supplyEmployees: "=",
            locationStatistics: "="
        },
        controller: "FulfillmentEditingModal",
        controllerAs: "ctrl"
    };
} ]).directive("editableOrderListing", [ "appProps", function(appProps) {
    return {
        restrict: "A",
        scope: !1,
        templateUrl: appProps.ctxPath + "/template/supply/manage/fulfillment/modal/editable-order-listing"
    };
} ]).controller("FulfillmentEditingModal", [ "$scope", "appProps", "modals", "SupplyRequisitionByIdApi", "SupplyLocationAutocompleteService", "SupplyItemAutocompleteService", fulfillmentEditingModal ]), essSupply = angular.module("essSupply");

essSupply.directive("fulfillmentImmutableModal", [ "appProps", "modals", "LocationService", function(appProps, modals, locationService) {
    function link($scope, $elem, $attrs) {
        $scope.requisition = modals.params(), $scope.close = function() {
            modals.resolve();
        };
    }
    return {
        templateUrl: appProps.ctxPath + "/template/supply/manage/fulfillment/modal/fulfillment-immutable-modal",
        link: link
    };
} ]);

var essSupply = angular.module("essSupply").controller("SupplyOrderController", [ "$scope", "appProps", "LocationService", "SupplyCartService", "PaginationModel", "SupplyLocationAutocompleteService", "SupplyLocationAllowanceService", "SupplyOrderDestinationService", "modals", "SupplyUtils", supplyOrderController ]);

essSupply.directive("destinationValidator", [ "SupplyLocationAutocompleteService", function(locationAutocompleteService) {
    return {
        require: "ngModel",
        link: function(scope, elm, attrs, ctrl) {
            ctrl.$validators.destination = function(modelValue, viewValue) {
                return locationAutocompleteService.isValidCode(modelValue) || 0 === modelValue.length;
            };
        }
    };
} ]), essSupply.directive("orderQuantityValidator", [ function() {
    return {
        require: "ngModel",
        link: function(scope, elm, attrs, ngModel) {
            elm.bind("keydown", function(event) {
                8 !== event.keyCode && 9 !== event.keyCode && 116 !== event.keyCode && (event.keyCode < 48 || event.keyCode > 57) && event.preventDefault();
            });
            var maxLength = 4;
            scope.$watch(attrs.ngModel, function(newValue) {
                var value = ngModel.$viewValue;
                value.length > maxLength && (ngModel.$setViewValue(value.substring(0, maxLength)), 
                ngModel.$render()), 0 == value.indexOf(0) && value.length > 1 && (ngModel.$setViewValue(value.substring(1, value.length)), 
                ngModel.$render());
            });
        }
    };
} ]), angular.module("essSupply").service("SupplyLocationAllowanceService", [ "SupplyLocationAllowanceApi", locationAllowanceService ]), 
essSupply.service("SupplyOrderDestinationService", [ "appProps", "SupplyCookieService", "EmpInfoApi", "SupplyLocationAutocompleteService", orderDestinationService ]), 
angular.module("essSupply").directive("orderMorePromptModal", [ "appProps", function(appProps) {
    return {
        templateUrl: appProps.ctxPath + "/template/supply/order/order-more-prompt-modal",
        controller: "OrderMorePromptModalCtrl",
        controllerAs: "ctrl"
    };
} ]).controller("OrderMorePromptModalCtrl", [ "$scope", "modals", function($scope, modals) {
    $scope.confirm = function() {
        modals.resolve(modals.params().allowance);
    }, $scope.nevermind = function() {
        modals.reject();
    };
} ]), angular.module("essSupply").directive("orderCustomQuantityModal", [ "appProps", function(appProps) {
    return {
        templateUrl: appProps.ctxPath + "/template/supply/order/order-custom-quantity-modal",
        controller: "OrderCustomQuantityModalCtrl",
        controllerAs: "ctrl"
    };
} ]).controller("OrderCustomQuantityModalCtrl", [ "$scope", "modals", "SupplyCartService", function($scope, modals, supplyCart) {
    function init() {
        params = modals.params();
        var lineItem = supplyCart.getCartLineItem(params.item.id);
        $scope.quantity = lineItem ? lineItem.quantity : 1;
    }
    var params = {};
    $scope.quantity = 1, init(), $scope.addToCart = function() {
        isNaN($scope.quantity) || (supplyCart.isItemInCart(params.item.id) && supplyCart.removeFromCart(params.item.id), 
        supplyCart.addToCart(params.item, $scope.quantity), modals.resolve());
    }, $scope.cancel = function() {
        modals.resolve();
    };
} ]), angular.module("essSupply").directive("specialOrderItemModal", [ "appProps", function(appProps) {
    return {
        templateUrl: appProps.ctxPath + "/template/supply/order/special-order-item-modal",
        controller: "SpecialOrderItemCtrl",
        controllerAs: "ctrl"
    };
} ]).controller("SpecialOrderItemCtrl", [ "$scope", "modals", "SupplyCartService", function($scope, modals, supplyCart) {
    var allowance = modals.params().allowance;
    $scope.cancel = function() {
        modals.resolve();
    }, $scope.addToCart = function() {
        supplyCart.addToCart(allowance.item, allowance.selectedQuantity), modals.resolve();
    };
} ]);

var essSupply = angular.module("essSupply");

essSupply.service("SupplyCartService", [ "SupplyLocationAllowanceService", "SupplyCookieService", function(allowanceService, cookies) {
    function LineItem(item, quantity) {
        this.item = item, this.quantity = quantity;
    }
    function newQuantity(quantity, lineItem) {
        return lineItem ? lineItem.quantity + quantity : quantity;
    }
    var cart = cookies.getCart();
    return {
        isOverOrderAllowance: function(item, quantity) {
            return newQuantity(quantity, this.getCartLineItem(item.id)) > item.maxQtyPerOrder;
        },
        addToCart: function(item, quantity) {
            return this.isItemInCart(item.id) ? this.getCartLineItem(item.id).quantity += quantity : cart.push(new LineItem(item, quantity)), 
            cookies.addCart(cart), !0;
        },
        getCart: function() {
            return cart;
        },
        isItemInCart: function(itemId) {
            var results = $.grep(cart, function(lineItem) {
                return lineItem.item.id === itemId;
            });
            return results.length > 0;
        },
        getCartLineItem: function(itemId) {
            var search = $.grep(cart, function(lineItem) {
                return lineItem.item.id === itemId;
            });
            return search.length > 0 ? search[0] : null;
        },
        getTotalItems: function() {
            var size = 0;
            return angular.forEach(cart, function(lineItem) {
                size += lineItem.quantity || 0;
            }), size;
        },
        removeFromCart: function(itemId) {
            $.grep(cart, function(lineItem, index) {
                lineItem && lineItem.item.id === itemId && cart.splice(index, 1);
            }), cookies.addCart(cart);
        },
        reset: function() {
            cart = [], cookies.addCart(cart);
        }
    };
} ]), essSupply = angular.module("essSupply").controller("SupplyCartController", [ "$scope", "SupplyCookieService", "SupplyCartService", "SupplyLocationAllowanceService", "SupplyRequisitionApi", "SupplyOrderDestinationService", "appProps", "modals", "LocationService", supplyCartController ]);

var essSupply = angular.module("essSupply");

essSupply.directive("cartSummary", [ "appProps", function(appProps) {
    return {
        restrict: "E",
        controller: function($scope, SupplyCartService) {
            $scope.getTotalItems = function() {
                return SupplyCartService.getTotalItems();
            };
        },
        templateUrl: appProps.ctxPath + "/template/supply/order/cart/cart-summary",
        transclude: !0
    };
} ]), essSupply.directive("cartCheckoutModal", [ "appProps", function(appProps) {
    return {
        restrict: "E",
        templateUrl: appProps.ctxPath + "/template/supply/order/cart/cart-checkout-modal",
        controller: "CartCheckoutModalCtrl",
        controllerAs: "ctrl"
    };
} ]).controller("CartCheckoutModalCtrl", [ "$scope", "modals", function($scope, modals) {
    $scope.requisitionId = modals.params().result.requisitionId;
} ]), essSupply = angular.module("essSupply").controller("SupplyViewController", [ "$scope", "SupplyRequisitionHistoryApi", "LocationService", "$window", "$timeout", "SupplyUtils", supplyViewController ]), 
essSupply = angular.module("essSupply"), essSupply.service("SupplyUtils", [ function() {
    return {
        alphabetizeLineItems: function(lineItems) {
            return lineItems.sort(function(a, b) {
                return a.item.description < b.item.description ? -1 : a.item.description > b.item.description ? 1 : 0;
            }), lineItems;
        },
        alphabetizeAllowances: function(allowances) {
            var allowancesCopy = angular.copy(allowances);
            return allowancesCopy.sort(function(a, b) {
                return a.item.description < b.item.description ? -1 : a.item.description > b.item.description ? 1 : 0;
            }), allowancesCopy;
        },
        countDistinctItemsInRequisition: function(requisition) {
            var count = 0;
            return requisition.lineItems && angular.forEach(requisition.lineItems, function(item) {
                count++;
            }), count;
        }
    };
} ]), essSupply.directive("capitalize", function($parse) {
    return {
        require: "ngModel",
        link: function(scope, element, attrs, modelCtrl) {
            var capitalize = function(inputValue) {
                void 0 === inputValue && (inputValue = ""), inputValue.indexOf("(") != -1 && (inputValue = inputValue.substring(0, inputValue.indexOf("(") - 1), 
                modelCtrl.$setViewValue(inputValue));
                var capitalized = inputValue.toUpperCase();
                return capitalized !== inputValue && (modelCtrl.$setViewValue(capitalized), modelCtrl.$render()), 
                capitalized;
            };
            modelCtrl.$parsers.push(capitalize), capitalize($parse(attrs.ngModel)(scope));
        }
    };
});

var essSupply = angular.module("essSupply");

essSupply.service("SupplyLocationStatisticsService", [ "$q", "SupplyLocationStatisticsApi", supplyLocationStatisticsService ]);
//# sourceMappingURL=ess-supply.min.js.map