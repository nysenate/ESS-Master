package gov.nysenate.ess.supply.authorization.responsibilityhead;

import com.google.common.base.Preconditions;
import gov.nysenate.ess.core.dao.base.SqlBaseDao;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

/**
 * Sql queries to get {@link TempResponsibilityHead}.
 *
 * A {@link TempResponsibilityHead} stores additional responsibility center head(RCH) codes
 * that an employee is allowed to order for in the supply app.
 */
@Repository
public class SqlTempResponsibilityHeadDao extends SqlBaseDao {

    /**
     * @return a list of all {@link TempResponsibilityHead} currently in effect.
     */
    public List<TempResponsibilityHead> allTempRch() {
        return allTempRch(LocalDateTime.now());
    }

    /**
     * @param effectiveDateTime
     * @return a list of all {@link TempResponsibilityHead} in effect at {@code effectiveDateTime}.
     */
    public List<TempResponsibilityHead> allTempRch(LocalDateTime effectiveDateTime) {
        Preconditions.checkNotNull(effectiveDateTime, "effectiveDateTime cannot be null.");

        MapSqlParameterSource params = new MapSqlParameterSource("effectiveDateTime", toDate(effectiveDateTime));
        String sql = SqlTempResponsibilityHeadQuery.ACTIVE_TEMP_RESP_HD.getSql(schemaMap());
        return localNamedJdbc.query(sql, params, new TempResponsibilityHeadRowMapper());
    }

    /**
     * @param empId the employee id.
     * @return a list of {@link TempResponsibilityHead} for an employee effective now.
     */
    public List<TempResponsibilityHead> tempRchForEmp(int empId) {
        return tempRchForEmp(empId, LocalDateTime.now());
    }

    /**
     * Gets an employee's additional RCH's effective at {@code dateTime}.
     * An employee can place supply orders for any location in these RCH's in addition to their own RCH.
     *
     * @param empId    The employee id. Must be greater than 0.
     * @param effectiveDateTime The datetime these records must be valid for. Cannot be null.
     * @return
     */
    public List<TempResponsibilityHead> tempRchForEmp(int empId, LocalDateTime effectiveDateTime) {
        Preconditions.checkArgument(empId > 0, "empId must be initialized.");
        Preconditions.checkNotNull(effectiveDateTime, "effectiveDateTime cannot be null.");

        MapSqlParameterSource params = new MapSqlParameterSource()
                .addValue("empId", empId)
                .addValue("effectiveDateTime", toDate(effectiveDateTime));
        String sql = SqlTempResponsibilityHeadQuery.ACTIVE_TEMP_RESP_HD_BY_EMP.getSql(schemaMap());
        return localNamedJdbc.query(sql, params, new TempResponsibilityHeadRowMapper());
    }

    /**
     * Save a {@link TempResponsibilityHead} to the database.
     * The temp rch is inserted if its {@code id} is null or 0, otherwise its updated.
     * @param rch The TempResponsibilityHead to be saved. Cannot be null.
     * @return The provided TempResponsibilityHead with its autogenerated id set if it was a new record.
     */
    public TempResponsibilityHead saveTempRch(TempResponsibilityHead rch) {
        Preconditions.checkNotNull(rch);

        MapSqlParameterSource params = new MapSqlParameterSource()
                .addValue("empId", rch.getEmployeeId())
                .addValue("rchCode", rch.getResponsibilityHeadCode())
                .addValue("startDate", toDate(rch.getStartDate()))
                .addValue("endDate", toDate(rch.getEndDate()));

        if (rch.getId() == null || rch.getId().equals(0)) {
            rch.setId(insertTempRch(params));
        }
        else {
            updateTempRch(params);
        }
        return rch;
    }

    private int insertTempRch(MapSqlParameterSource params) {
        String sql = SqlTempResponsibilityHeadQuery.INSERT_TEMP_RESP_HD.getSql(schemaMap());
        KeyHolder keyHolder = new GeneratedKeyHolder();
        localNamedJdbc.update(sql, params, keyHolder);
        return (Integer)keyHolder.getKeys().get("id");
    }

    private void updateTempRch(MapSqlParameterSource params) {
        String sql = SqlTempResponsibilityHeadQuery.UPDATE_TEMP_RESP_HD.getSql(schemaMap());
        localNamedJdbc.update(sql, params);
    }

    /**
     * Deletes a {@link TempResponsibilityHead}
     * @param rch The temp RCH to delete.
     */
    public void deleteTempRch(TempResponsibilityHead rch) {
        MapSqlParameterSource params = new MapSqlParameterSource("id", rch.getId());
        String sql = SqlTempResponsibilityHeadQuery.DELETE_TEMP_RESP_HD.getSql(schemaMap());
        localNamedJdbc.update(sql, params);
    }
}
